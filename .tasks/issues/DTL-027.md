---
id: DTL-027
title: "Add entity connectivity validation"
type: feature
status: ready
labels:
  - stack:backend
  - type:feature
  - priority:medium
  - state:has-strategy
  - state:has-spec
parent: DTL-022
created: 2025-11-18T00:00:00Z
updated: 2025-11-18T00:00:00Z
---

# DTL-027: Add entity connectivity validation

## Description

Implement validation to ensure all measures required by a metric are reachable via join graph from the primary entity.

## What needs to be built

### Join Graph Analysis

**Build Reachability Map**:
```python
def build_join_graph(
    base_model: SemanticModel,
    all_models: list[SemanticModel],
    max_hops: int = 2
) -> dict[str, int]:
    """
    Build a map of which semantic models are reachable from base_model.

    Uses BFS to traverse foreign key relationships.

    Returns: {
        "rental_orders": 0,  # Base model
        "users": 1,          # Direct join (1 hop)
        "searches": 1,       # Direct join (1 hop)
        "sessions": 2,       # Multi-hop via searches (2 hops)
    }

    Models beyond max_hops are not included.
    """
```

### Metric Validation

**Validate Connectivity**:
```python
def validate_metric_connectivity(
    metric: Metric,
    primary_model: SemanticModel,
    all_models: list[SemanticModel]
) -> ValidationResult:
    """
    Verify all measures required by metric are reachable from primary_model.

    Raises ValidationError with helpful message if not reachable:
    - Which measure is unreachable
    - Which model contains that measure
    - Suggestion to change primary_entity or use derived table
    """
```

### Validation Checks

1. **Primary entity exists**: Entity name is valid in some semantic model
2. **Measures exist**: All referenced measures exist in semantic models
3. **Measures reachable**: All measure models are in join graph
4. **Join depth**: All required models are within 2 hops (dbt limit)

### Error Messages

**Example 1: Unreachable measure**
```
ValidationError: Metric 'conversion_rate' cannot be generated.

Primary Entity: user
Base Model: users
Unreachable Measure: session_count (from sessions model)

The 'sessions' model is not reachable from 'users' via foreign key relationships.

Suggestions:
- Change primary_entity to an entity that connects both models
- Add a foreign key relationship between users and sessions
- Consider using a derived table approach for this metric
```

**Example 2: Missing primary entity**
```
ValidationError: Metric 'search_conversion_rate' requires explicit primary_entity.

The metric references measures from multiple entities:
- rental_count (from rental_orders.rental entity)
- search_count (from searches.search entity)

Cannot infer which entity should own this metric.

Specify primary_entity in the meta block:

meta:
  primary_entity: search  # or 'rental'
```

**Example 3: Primary entity doesn't exist**
```
ValidationError: Metric 'revenue_per_user' specifies invalid primary_entity.

primary_entity: 'customer'

No semantic model has an entity named 'customer'.

Available entities:
- rental (from rental_orders)
- search (from searches)
- user (from users)

Update meta block with valid entity name.
```

**Example 4: Measure doesn't exist**
```
ValidationError: Metric 'search_conversion_rate' references unknown measure.

Measure: 'rental_count'

This measure does not exist in any semantic model.

Available measures:
- total_revenue (from rental_orders)
- checkout_amount (from rental_orders)
- search_count (from searches)

Check metric definition and measure names.
```

### Integration Points

- **Parser validation**: Run during metric parsing (early validation)
- **Generator validation**: Run before LookML generation (final check)
- **CLI flag**: Support `--strict` mode for failing on warnings
- **Return validation report**: List of all issues found, not just first

## Why it's needed (connection to epic)

Prevents generating invalid LookML that would error at query time. Provides clear feedback to users about metric configuration issues before they try to use the generated LookML.

## Technical scope from labels

Backend work in `src/dbt_to_lookml/`:
- Add validation module or extend existing
- Integrate with metric parser (early validation)
- Integrate with generator (pre-generation check)
- Clear error messages with actionable suggestions
- Build join graph using existing BFS logic from generator

## Acceptance Criteria

- [ ] `build_join_graph()` correctly identifies reachable models
- [ ] `validate_metric_connectivity()` detects unreachable measures
- [ ] Validation detects missing primary_entity
- [ ] Validation detects invalid primary_entity name
- [ ] Validation detects missing measures
- [ ] Error messages include helpful suggestions
- [ ] Validation integrates with parser
- [ ] Validation integrates with generator
- [ ] `--strict` mode available in CLI

## Testing requirements

**Unit tests** (in `src/tests/unit/test_validation.py` or similar):
- Test `build_join_graph()` with various model structures
- Test valid metric (all measures reachable)
- Test unreachable measure (model not in join graph)
- Test missing primary_entity
- Test invalid primary_entity name
- Test missing measure
- Test multi-hop reachability
- Test max hop limit (3+ hops should error/warn)
- Test error message content

**Integration tests** (in `src/tests/integration/`):
- Test validation with real semantic models and metrics
- Test validation error messages end-to-end
- Test --strict mode behavior

**Coverage target**: 95%+ branch coverage

## Dependencies

- DTL-023 (needs Metric schema models)
- DTL-024 (needs parsed metrics)

## Blocked by

- DTL-023
- DTL-024

## Blocks

- DTL-028 (tests need validation)

## Links
- Epic: [DTL-022](./../epics/DTL-022.md)
- Depends on: [DTL-023](./../issues/DTL-023.md), [DTL-024](./../issues/DTL-024.md)
- Implementation plan: .tasks/plans/cross-entity-metrics-plan.yaml
- Implementation strategy: [DTL-027-strategy.md](./../strategies/DTL-027-strategy.md)

## Notes

### Reuse Existing Join Graph Logic

The generator already has `_build_join_graph()` for explore generation. We can reuse similar BFS logic for validation:

```python
def build_join_graph(
    base_model: SemanticModel,
    all_models: list[SemanticModel],
    max_hops: int = 2
) -> dict[str, int]:
    reachable = {base_model.name: 0}
    queue = deque([(base_model, 0)])
    visited = {base_model.name}

    while queue:
        current_model, depth = queue.popleft()

        if depth >= max_hops:
            continue

        for entity in current_model.entities:
            if entity.type != "foreign":
                continue

            target_model = find_model_by_primary_entity(entity.name, all_models)
            if target_model and target_model.name not in visited:
                visited.add(target_model.name)
                reachable[target_model.name] = depth + 1
                queue.append((target_model, depth + 1))

    return reachable
```

### Validation Timing

**Early Validation** (during parsing):
- Check primary_entity existence
- Check measure existence
- Fast fail for configuration errors

**Late Validation** (before generation):
- Check entity connectivity (requires full join graph)
- Final verification before LookML generation

## History
### 2025-11-18 00:00 - Issue Created
Created from epic DTL-022

### 2025-11-18 - Implementation Strategy Completed
Comprehensive implementation strategy created with:
- Standalone validation module architecture
- BFS join graph logic extraction and generalization
- Two-phase validation (parser + generator integration)
- Rich error message templates with actionable suggestions
- 95%+ test coverage plan
- Phased implementation roadmap

### 2025-11-18 - Implementation Spec Generated
Detailed implementation specification created (.tasks/specs/DTL-027-spec.md):
- 9 implementation phases with 25 discrete tasks
- Complete code examples for all core components
- Comprehensive testing strategy (23+ test cases)
- Performance benchmarks and optimization strategies
- Error message templates with rich formatting
- Migration path and backward compatibility plan
- Issue status updated to "ready" with state:has-spec label
